-- File: qdr2AxiLite/qdr2AxiLite.vhd
-- Generated by MyHDL 0.9.0
-- Date: Thu Mar 24 11:46:48 2016


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_090.all;

entity qdr2AxiLite is
    port (
        clk: in std_logic;
        rst: in std_logic;
        qdr_wr_cmd0: out std_logic;
        qdr_rd_addr0: out std_logic_vector(17 downto 0);
        qdr_rd_valid0: in std_logic;
        qdr_rd_cmd0: out std_logic;
        qdr_wr_bw_n0: out std_logic_vector(17 downto 0);
        qdr_wr_addr0: out std_logic_vector(17 downto 0);
        qdr_wr_data0: out std_logic_vector(143 downto 0);
        qdr_rd_data0: in std_logic_vector(143 downto 0);
        axiAr_valid: in std_logic;
        axiAr_ready: out std_logic;
        axiAr_addr: in std_logic_vector(31 downto 0);
        axiR_valid: out std_logic;
        axiR_resp: out std_logic_vector(1 downto 0);
        axiR_ready: in std_logic;
        axiR_data: out std_logic_vector(63 downto 0);
        axiAw_valid: in std_logic;
        axiAw_ready: out std_logic;
        axiAw_addr: in std_logic_vector(31 downto 0);
        axiB_valid: out std_logic;
        axiB_resp: out std_logic_vector(1 downto 0);
        axiB_ready: in std_logic;
        axiW_valid: in std_logic;
        axiW_ready: out std_logic;
        axiW_data: in std_logic_vector(63 downto 0);
        axiW_strb: in std_logic_vector(7 downto 0)
    );
end entity qdr2AxiLite;
-- For simplicity address has to be aligned to qdr address granularity
-- 
-- unit was implemented for 
-- axilite - 32b addr, 32b data  
-- qdr - 18b addr, 36b data

architecture MyHDL of qdr2AxiLite is


constant axiAW: integer := 2**5;
constant RESP_OKAY: integer := 0;


type t_enum_t_rFsm_1 is (
    RREADY,
    RRESP
);
type t_enum_t_wFsm_2 is (
    WREADY,
    WCATCH,
    BRESP
);

signal axiW_data_num: unsigned(63 downto 0);
signal axiB_resp_num: unsigned(1 downto 0);
signal qdr_wr_addr0_num: unsigned(17 downto 0);
signal wSt_next: t_enum_t_wFsm_2;
signal rDataReg: unsigned(143 downto 0);
signal axiAw_addr_num: unsigned(31 downto 0);
signal axiAr_addr_num: unsigned(31 downto 0);
signal wSt: t_enum_t_wFsm_2;
signal axiR_resp_num: unsigned(1 downto 0);
signal rSt: t_enum_t_rFsm_1;
signal qdr_rd_data0_num: unsigned(143 downto 0);
signal qdr_wr_data0_num: unsigned(143 downto 0);
signal rSt_next: t_enum_t_rFsm_1;
signal wAddrReg: unsigned(31 downto 0);
signal qdr_rd_addr0_num: unsigned(17 downto 0);
signal qdr_wr_bw_n0_num: unsigned(17 downto 0);
signal axiW_strb_num: unsigned(7 downto 0);
signal axiR_data_num: unsigned(63 downto 0);

begin

qdr_rd_addr0 <= std_logic_vector(qdr_rd_addr0_num);
qdr_wr_bw_n0 <= std_logic_vector(qdr_wr_bw_n0_num);
qdr_wr_addr0 <= std_logic_vector(qdr_wr_addr0_num);
qdr_wr_data0 <= std_logic_vector(qdr_wr_data0_num);
qdr_rd_data0_num <= unsigned(qdr_rd_data0);
axiAr_addr_num <= unsigned(axiAr_addr);
axiR_resp <= std_logic_vector(axiR_resp_num);
axiR_data <= std_logic_vector(axiR_data_num);
axiAw_addr_num <= unsigned(axiAw_addr);
axiB_resp <= std_logic_vector(axiB_resp_num);
axiW_data_num <= unsigned(axiW_data);
axiW_strb_num <= unsigned(axiW_strb);





axiR_data_num <= resize(rDataReg, 64);
axiR_resp_num <= to_unsigned(RESP_OKAY, 2);
axiR_valid <= stdl(rSt = RRESP);


QDR2AXILITE_AXIREADDATATOREG: process (clk) is
begin
    if rising_edge(clk) then
        if (rst = '0') then
            rDataReg <= to_unsigned(0, 144);
        else
            if bool(qdr_rd_valid0) then
                rDataReg <= qdr_rd_data0_num;
            else
                rDataReg <= rDataReg;
            end if;
        end if;
    end if;
end process QDR2AXILITE_AXIREADDATATOREG;


QDR2AXILITE_AXIREADADDR: process (axiAr_valid, rSt, axiAr_addr_num) is
begin
    qdr_rd_addr0_num <= resize(axiAr_addr_num(32-1 downto (axiAW - 5)), 18);
    if (rSt = RREADY) then
        axiAr_ready <= '1';
        qdr_rd_cmd0 <= axiAr_valid;
    else
        qdr_rd_cmd0 <= '0';
        axiAr_ready <= '0';
    end if;
end process QDR2AXILITE_AXIREADADDR;


QDR2AXILITE_RFSMTRANSITIONS: process (axiAr_valid, rSt, axiR_ready) is
begin
    if ((rSt = RREADY) and bool(axiAr_valid)) then
        rSt_next <= RRESP;
    elsif ((rSt = RRESP) and bool(axiR_ready)) then
        rSt_next <= RREADY;
    else
        rSt_next <= rSt;
    end if;
end process QDR2AXILITE_RFSMTRANSITIONS;


QDR2AXILITE_AXIWRITEADDRCOMB: process (wSt) is
begin
    if (wSt = WREADY) then
        axiAw_ready <= '1';
    else
        axiAw_ready <= '0';
    end if;
end process QDR2AXILITE_AXIWRITEADDRCOMB;


QDR2AXILITE_AXIWRITEADDRREGPROC: process (clk) is
begin
    if rising_edge(clk) then
        if (rst = '0') then
            wAddrReg <= to_unsigned(0, 32);
        else
            if (wSt = WREADY) then
                wAddrReg <= resize(axiAw_addr_num(32-1 downto (axiAW - 5)), 32);
            else
                wAddrReg <= wAddrReg;
            end if;
        end if;
    end if;
end process QDR2AXILITE_AXIWRITEADDRREGPROC;


QDR2AXILITE_AXIWRITEDATA: process (axiW_data_num, axiW_strb_num, wAddrReg, wSt, axiW_valid) is
begin
    qdr_wr_addr0_num <= resize(wAddrReg, 18);
    qdr_wr_data0_num <= resize(axiW_data_num, 144);
    qdr_wr_bw_n0_num <= resize(axiW_strb_num, 18);
    if (wSt = WCATCH) then
        axiW_ready <= '1';
        qdr_wr_cmd0 <= axiW_valid;
    else
        axiW_ready <= '0';
        qdr_wr_cmd0 <= '0';
    end if;
end process QDR2AXILITE_AXIWRITEDATA;


QDR2AXILITE_WFSMTRANSITIONS: process (axiB_ready, wSt, axiW_valid, axiAw_valid) is
begin
    if ((wSt = WREADY) and bool(axiAw_valid)) then
        wSt_next <= WCATCH;
    elsif ((wSt = WCATCH) and bool(axiW_valid)) then
        wSt_next <= BRESP;
    elsif ((wSt = BRESP) and bool(axiB_ready)) then
        wSt_next <= WREADY;
    else
        wSt_next <= wSt;
    end if;
end process QDR2AXILITE_WFSMTRANSITIONS;



axiB_resp_num <= to_unsigned(RESP_OKAY, 2);
axiB_valid <= stdl(wSt = BRESP);


QDR2AXILITE_FSMSTSHIFT: process (clk) is
begin
    if rising_edge(clk) then
        if (rst = '0') then
            rSt <= RREADY;
            wSt <= WREADY;
        else
            rSt <= rSt_next;
            wSt <= wSt_next;
        end if;
    end if;
end process QDR2AXILITE_FSMSTSHIFT;

end architecture MyHDL;
