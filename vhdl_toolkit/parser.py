#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from vhdl_toolkit.entity import Entity
from antlr4 import CommonTokenStream, ParseTreeWalker, InputStream 
from vhdl_toolkit.vhdlLexer import vhdlLexer
from vhdl_toolkit.vhdlParser import vhdlParser
from vhdl_toolkit.vhdlListener import vhdlListener
from vhdl_toolkit.variables import PortItem, VHDLGeneric
from vhdl_toolkit.types import VHDLType
from vhdl_toolkit.synthetisator.param import getParam

#rom time import time
import re, dill
import os
import hashlib

comentRegex = re.compile('--[^\n]*\n')

"""
Parser is generated by antlr4

https://github.com/antlr/antlr4/blob/master/doc/getting-started.md
https://github.com/antlr/antlr4
https://github.com/antlr/grammars-v4/blob/master/vhdl/vhdl.g4
https://github.com/loranbriggs/Antlr/blob/master/The%20Definitive%20ANTLR%204%20Reference.pdf
"""

class HDLRedefinitionErr(Exception):
    pass

class HDLParseErr(Exception):
    pass

class vhdlIdListener(vhdlListener):
    def __init__(self, idList):
        self.idList = idList
        
    def enterIdentifier(self, ctx):
        self.idList.append(ctx.getText())

class HDLCtx(dict):
    def __setitem__(self, key, val):
        if key in self:
            raise HDLRedefinitionErr(key)
        dict.__setitem__(self, key, val)

class vhdlGenericListener(vhdlListener):
    pass

class vhdlEntityListener(vhdlListener):
    def __init__(self, hdlCtx):
        self.hdlCtx = hdlCtx
        
    def enterEntity_declaration(self, ctx):
        self.e = Entity()
        self.e.name = ctx.children[1].children[0].getText()
    def enterInterface_constant_declaration(self, ctx):
        ids = []
        w = ParseTreeWalker()
        idListn = vhdlIdListener(ids)
        w.walk(idListn, ctx.children[0])
        
        var_type = VHDLType()
        # var_type.ast = ctx.children[2]
        var_type.str = ctx.children[2].getText()
         
        defaultVal = 0  # [TODO] first(ctx.children, lambda x : x) 
        
        for name in ids:
            g = VHDLGeneric(name, var_type, defaultVal)
            self.e.generics.append(g)
            
    def enterInterface_port_declaration(self, ctx):        
        portIds = []
        w = ParseTreeWalker()
        idListn = vhdlIdListener(portIds)
        w.walk(idListn, ctx.children[0])
        
        portDirection = ctx.children[2].getText().upper()

        portType = VHDLType()
        t = ctx.children[3]
        # portType.str = t.getText()
        t_id = t.children[0].getText().lower() 
        if t_id == 'std_logic':
            width = lambda ctx: 1
        elif t_id == 'std_logic_vector':
            cntx_name = 'ctx'
            def termToStr(t):
                if hasattr(t, 'factor'):
                    symbol = t.factor()[0].children[0].children[0].children[0].children[0].children[0].symbol
                    if symbol.type == vhdlParser.INTEGER: 
                        return symbol.text 
                    elif symbol.type == vhdlParser.RULE_index_constraint:
                        
                        return "getParam(%s[%s])" % (cntx_name, symbol.text)
                    else:
                        raise NotImplementedError()
                else:
                    raise NotImplementedError() 
            r = t.constraint().index_constraint().discrete_range()[0].range().explicit_range()
            assert(r.direction().getText().lower() == 'downto')
            r_to, r_from = r.simple_expression()
            assert(r_from.getText() == '0')
            width_str = 'lambda  %s : ' % (cntx_name)
            for ch in r_to.children:
                if isinstance(ch, vhdlParser.TermContext):
                    width_str += termToStr(ch)
                elif isinstance(ch, vhdlParser.Adding_operatorContext):
                    width_str += ch.getText()
                else:
                    NotImplementedError("Can not convert expression %s to python" % (r_to.getText()))
            width = eval(width_str)
        else:
            raise NotImplementedError('Can not convert type %s from vhdl to internal representation of vhdl_toolkit' % (t_id))
        portType.width = width    
        
        # portType.ast = ctx.children[3]
        
        portDefVal = None
        # if len(ctx.children) > 5:
        #    portDefVal = ctx.children[5]
        for pName in portIds:
            p = PortItem(pName, portDirection, portType)
            self.e.port.append(p) 

    def exitEntity_declaration(self, ctx):
        self.hdlCtx[self.e.name] = self.e
        
def rmComents(s):
    return comentRegex.sub('\n', s)


def processFile(fileName, doCacheUpdate=False):
    cacheFile = os.path.join(os.path.dirname(fileName) , '__pycache__', os.path.basename(fileName) + ".dill")
    with open(fileName,'rb') as f:
        fileHash = hashlib.md5(f.read()).hexdigest()
    try:
        # load from cache file
        with open(cacheFile, 'rb') as f:
            hdlCtx = dill.load(f)
            if hdlCtx.hash != fileHash:
                print("has is different", )
                raise IOError('File was edited', hdlCtx.hash, fileHash)
    except IOError:
        # parse file
        with open(fileName) as f:
            hdlCtx = process(InputStream(rmComents(f.read())))
        hdlCtx.hash = fileHash
        # save cahe
        os.makedirs(os.path.dirname(cacheFile), exist_ok=True)
        with open(cacheFile, "wb") as f:
            dill.dump(hdlCtx, f)
    
    return hdlCtx
    
        
def entityFromFile(fileName):
    ctx = processFile(fileName)
    entityes = []
    for _, o  in ctx.items():
        if isinstance(o, Entity):
            entityes.append(o)
    assert(len(entityes) == 1)
    return entityes[0]

            
def process(input_stream):
    hdlCtx = HDLCtx()
    #s = time()
    lexer = vhdlLexer(input_stream)
    stream = CommonTokenStream(lexer)
    parser = vhdlParser(stream)
    #s2 = time()
    #print('lex, pars - build', s2 - s)
    #s = s2
    tree = parser.design_file()  # ddesign_file is first rule
    #s2 = time()
    #print('parsing          ', s2 - s)
    #s = s2
    
    walker = ParseTreeWalker();
    listener = vhdlEntityListener(hdlCtx);
    walker.walk(listener, tree);
    #s2 = time()
    #print('walking ast      ', s2 - s)
    #s = s2
    
    return hdlCtx

    
   
if __name__ == "__main__":
    # simplest_b
    # axiLite_basic_slave2
    # axi4-stream-bfm-master
    # user
    # axiLite_basic_slave
    hdlCtx = processFile('samples/iLvl/vhdl/dualportRAM.vhd')
    print(hdlCtx)
