#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re
from subprocess import Popen, PIPE
import json
import inspect
import os

from vhdl_toolkit.entity import Entity
from vhdl_toolkit.variables import PortItem, VHDLGeneric
from vhdl_toolkit.types import VHDLType
from vhdl_toolkit.expr import BinOp
from vhdl_toolkit.synthetisator.param import Param
from vhdl_toolkit.reference import VhdlLocalRef, VhdlReference
comentRegex = re.compile('--[^\n]*\n')

"""
Parser is generated by antlr4, and is in Java because in Python it is incredibly slow (20min vs 0.2s)

https://github.com/antlr/antlr4/blob/master/doc/getting-started.md
https://github.com/antlr/antlr4
https://github.com/antlr/grammars-v4/blob/master/vhdl/vhdl.g4
https://github.com/loranbriggs/Antlr/blob/master/The%20Definitive%20ANTLR%204%20Reference.pdf

"""
class BaseVhdlContext():
    std_logic = VhdlLocalRef(["std_logic"]) 
    std_logic_vector = VhdlLocalRef(["std_logic_vector"]) 
    integer = VhdlLocalRef(["integer"])
    bool = VhdlLocalRef(["bool"])
    string = VhdlLocalRef(["string"])
    float = VhdlLocalRef(["float"])
    
    @classmethod
    def getBaseCtx(cls):
        d = {}
        for n  in [cls.std_logic, cls.std_logic_vector,
                   cls.integer, cls.bool, cls.string, cls.float]:
            d[n] = n
        return d
    
 
    
class HDLRedefinitionErr(Exception):
    pass

class HDLParseErr(Exception):
    pass

baseDir = os.path.dirname(inspect.getfile(HDLRedefinitionErr))
convertor = os.path.join(baseDir, "vhdlConvertor", "vhdlConvertor.jar")
 
class NonRedefDict(dict):
    def __setitem__(self, key, val):
        if key in self:
            raise HDLRedefinitionErr(key)
        dict.__setitem__(self, key, val)


class HDLCtx():
    def __init__(self):
        self.entities = NonRedefDict()
        self.architectures = []
        self.packages = NonRedefDict()
        self.ctx = BaseVhdlContext.getBaseCtx()
    def __str__(self):
        return "\n".join([
                    "\n".join([str(e) for _, e in self.entities.items()]),
                    "\n".join([str(a) for a in self.architectures]),
                    "\n".join([str(p) for p in self.packages]),
                    ])
    @staticmethod
    def exprFromJson(jExpr, ctx):
        lit = jExpr.get("literal", None)
        if lit:
            # vhldConvertor.vhdlSymbolType
            t = lit['type']
            v = lit['value']
            if t == 'ID':
                v = ctx[VhdlLocalRef([v])]
            elif t == 'INT':
                v = int(v)
            elif t == 'float':
                v = float(v)
            else:
                raise HDLParseErr("Unknown type of literal %s" % (t))
            return v
        binOp = jExpr['binOperator']
        if binOp:
            op0 = HDLCtx.exprFromJson(binOp['op0'], ctx)
            operator = binOp['operator']
            op1 = HDLCtx.exprFromJson(binOp['op1'], ctx)
            expr = BinOp(op0, operator, op1)
            return expr 
        raise HDLParseErr("Unparsable expression %s" % (str(jExpr)))
    
    @staticmethod    
    def portFromJson(jPort, ctx):
        v = jPort['variable']
        var_type = HDLCtx.typeFromJson(v['type'], ctx)
        p = PortItem(v['name'], jPort['direction'], var_type)
        val = v['value']
        if val != None:
            p.defaultVal = HDLCtx.exprFromJson(val, ctx)
        return p
    
    @staticmethod
    def typeFromJson(jType, ctx):
        var_t = VHDLType()
        var_t.ctx = ctx
        try:
            t_name = VhdlLocalRef.fromJson(jType['literal']['value'])
            if t_name == BaseVhdlContext.integer:
                var_t.width = int
            elif t_name == BaseVhdlContext.float:
                var_t.width = float
            elif t_name == BaseVhdlContext.std_logic:
                var_t.width = 1
            elif t_name == BaseVhdlContext.string:
                var_t.width = str
            else:
                raise HDLParseErr("Unknown type name %s" % (t_name))
        except KeyError:
            # typeName = t[]
            op = jType['binOperator']
            t_name = VhdlLocalRef.fromJson(op['op0']['literal']['value'])
            if t_name != BaseVhdlContext.std_logic_vector:
                raise NotImplementedError("Type conversion is not implemented for type %s" % t_name)
            var_t.width = HDLCtx.exprFromJson(op['op1'], ctx)
            
        return var_t
    
    def genericFromJson(self, jGeneric):
        t = jGeneric["type"]
        name = jGeneric['name'].lower()
        g = VHDLGeneric(name, HDLCtx.typeFromJson(t, self.ctx), self.ctx)
        g.defaultVal = Param(HDLCtx.exprFromJson(jGeneric['value'], self.ctx))
        g.defaultVal.name = name
        g.name = name
        return g
    
    def entityFromJson(self, jEnt):
        e = Entity()
        e.name = jEnt['name']
        for _, jGener in jEnt['generics'].items():
            g = self.genericFromJson(jGener)
            e.generics.append(g)
        ctx = e.ctxFromGenerics()
        ctx.update(self.ctx)
        for _ , jPort in jEnt['ports'].items():
            p = HDLCtx.portFromJson(jPort, ctx)
            e.port.append(p)
        return e
                
        
    def load(self, jsonctx, fileName):
        dependencies = set()
        for jsnU in jsonctx['usings']:
            u = VhdlReference.fromJson(jsnU)
            dependencies.add(u)
        for eName, e in jsonctx["entities"].items():
            ent = self.entityFromJson(e)
            ent.fileName = fileName
            ent.dependencies = dependencies
            self.entities[eName] = ent
        print(dependencies)    

class VhdlLib(HDLCtx):
    def __init__(self, name):
        self.name = name
        self.fileContexts = NonRedefDict()
        self.packages = NonRedefDict()
        self.entities = NonRedefDict()
                

        
def entityFromFile(fileName):
    ctx = process([fileName])
    assert(len(ctx.entities.items()) == 1)
    return list(ctx.entities.items())[0][1]

            
def process(fileList:list, hdlCtx=None, timeoutInterval=20):

    if not hdlCtx:
        hdlCtx = HDLCtx()
    
    p_list = []
    for fname in fileList:
        p = Popen(["java", "-jar", str(convertor) , fname], stdout=PIPE) 
        p.fileName = fname
        p_list.append(p)
        
    for p in p_list:
        stdoutdata, _ = p.communicate(timeout=timeoutInterval)

        if p.returncode != 0:
            raise Exception("Failed to parse file %s" % (p.fileName))
        j = json.loads(stdoutdata.decode("utf-8"))
        hdlCtx.load(j, p.fileName)
    
    return hdlCtx

    
   
if __name__ == "__main__":
    fl = ['samples/iLvl/vhdl/dualportRAM.vhd']
    hdlCtx = process(fl)
    print(hdlCtx)
