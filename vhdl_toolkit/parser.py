#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from vhdl_toolkit.entity import Entity
from antlr4 import CommonTokenStream, ParseTreeWalker, InputStream 
from vhdl_toolkit.vhdlLexer import vhdlLexer
from vhdl_toolkit.vhdlParser import vhdlParser
from vhdl_toolkit.vhdlListener import vhdlListener
from vhdl_toolkit.variables import PortItem, VHDLGeneric
from vhdl_toolkit.types import VHDLType
from vhdl_toolkit.synthetisator.param import getParam

# rom time import time
import re, dill
import os
import hashlib

comentRegex = re.compile('--[^\n]*\n')

"""
Parser is generated by antlr4

https://github.com/antlr/antlr4/blob/master/doc/getting-started.md
https://github.com/antlr/antlr4
https://github.com/antlr/grammars-v4/blob/master/vhdl/vhdl.g4
https://github.com/loranbriggs/Antlr/blob/master/The%20Definitive%20ANTLR%204%20Reference.pdf

# [TODO] this style of using listeners is antipatent
"""

class HDLRedefinitionErr(Exception):
    pass

class HDLParseErr(Exception):
    pass

class vhdlIdListener(vhdlListener):
    def __init__(self, idList):
        self.idList = idList
        
    def enterIdentifier(self, ctx):
        self.idList.append(ctx.getText())

class HDLCtx(dict):
    def __setitem__(self, key, val):
        if key in self:
            raise HDLRedefinitionErr(key)
        dict.__setitem__(self, key, val)


class vhdlExprListener(vhdlListener):
    def __init__(self, ctxName):
        vhdlListener.__init__(self)
        self.exprStr = []
        self.ctxName = ctxName
        
    def _getExprStr(self):
        return 'lambda  %s : %s' % (self.ctxName, ''.join(self.exprStr))
    def getExpr(self):
        return eval(self._getExprStr())
    def getExprAsWidht(self):
        return eval(self._getExprStr() + '+1')
    def enterIdentifier(self, ctx):
        s = "getParam(%s['%s'])" % (self.ctxName, ctx.getText().lower())
        self.exprStr.append(s)
    
    def enterNumeric_literal(self, ctx):
        s = ctx.getText()
        self.exprStr.append(s)

    def enterPrimary(self, ctx):
        try:
            if len(ctx.children) == 3 and  ctx.children[0].symbol.type == vhdlParser.LPAREN:
                s = "("
                self.exprStr.append(s)
        except AttributeError:
            pass
        
    def exitPrimary(self, ctx):
        try:
            if len(ctx.children) == 3 and ctx.children[2].symbol.type == vhdlParser.RPAREN:
                s = ")"
                self.exprStr.append(s)
        except AttributeError:
            pass
        
    def enterAdding_operator(self, ctx):
        s = ctx.getText()
        self.exprStr.append(s)
        
    def enterMultiplying_operator(self, ctx):
        d = {vhdlParser.DIV : "//",
             vhdlParser.MUL : "*",
             vhdlParser.MOD: "%"}
        s = d[ctx.children[0].symbol.type]
        self.exprStr.append(s)

def parseType(t_ctx, nameCtx):
        t = VHDLType()
        t.ctx = nameCtx
        
        t_id = t_ctx.children[0].getText().lower() 
        if t_id == 'std_logic':
            width = lambda ctx: 1
        elif t_id == 'std_logic_vector':
            cntx_name = 'ctx'
            r = t_ctx.constraint().index_constraint().discrete_range()[0].range().explicit_range()
            assert(r.direction().getText().lower() == 'downto')
            r_to, r_from = r.simple_expression()
            assert(r_from.getText() == '0')
            
            l = vhdlExprListener(cntx_name)
            w = ParseTreeWalker()
            w.walk(l, r_to)

            width = l.getExprAsWidht()
        elif t_id == 'integer':
            width = int
        else:
            raise NotImplementedError(('Can not convert type %s from vhdl to internal representation' + 
                                       ' of vhdl_toolkit') % (t_id))
        t.width = width  
        return t 

class vhdlEntityListener(vhdlListener):
    def __init__(self, hdlCtx):
        self.hdlCtx = hdlCtx
        
    def enterEntity_declaration(self, ctx):
        self.e = Entity()
        self.e.name = ctx.children[1].children[0].getText()
    
    def enterInterface_constant_declaration(self, ctx):
        ids = []
        w = ParseTreeWalker()
        idListn = vhdlIdListener(ids)
        w.walk(idListn, ctx.children[0])
        
        var_type = parseType(ctx.children[2], self.e.ctx)
         
        defaultVal = 0
        
        for name in ids:
            g = VHDLGeneric(name, var_type, defaultVal)
            self.e.generics.append(g)
            self.e.ctx[name.lower()] = defaultVal
            
    def enterInterface_port_declaration(self, ctx):        
        portIds = []
        w = ParseTreeWalker()
        idListn = vhdlIdListener(portIds)
        w.walk(idListn, ctx.children[0])
        
        portDirection = ctx.children[2].getText().upper()
        t_ctx = ctx.children[3]
        portType = parseType(t_ctx, self.e.ctx)
        
        # portType.ast = ctx.children[3]
        
        portDefVal = None
        # if len(ctx.children) > 5:
        #    portDefVal = ctx.children[5]
        for pName in portIds:
            p = PortItem(pName, portDirection, portType)
            self.e.port.append(p) 

    def exitEntity_declaration(self, ctx):
        self.hdlCtx[self.e.name] = self.e
        
def rmComents(s):
    return comentRegex.sub('\n', s)


def processFile(fileName, doCacheUpdate=False):
    cacheFile = os.path.join(os.path.dirname(fileName) , '__pycache__', os.path.basename(fileName) + ".dill")
    with open(fileName, 'rb') as f:
        fileHash = hashlib.md5(f.read()).hexdigest()
    try:
        # load from cache file
        with open(cacheFile, 'rb') as f:
            hdlCtx = dill.load(f)
            if hdlCtx.hash != fileHash:
                print("has is different",)
                raise IOError('File was edited', hdlCtx.hash, fileHash)
    except IOError:
        # parse file
        with open(fileName) as f:
            hdlCtx = process(InputStream(rmComents(f.read())))
        hdlCtx.hash = fileHash
        # save cahe
        os.makedirs(os.path.dirname(cacheFile), exist_ok=True)
        with open(cacheFile, "wb") as f:
            dill.dump(hdlCtx, f)
    
    return hdlCtx
    
        
def entityFromFile(fileName):
    ctx = processFile(fileName)
    entityes = []
    for _, o  in ctx.items():
        if isinstance(o, Entity):
            entityes.append(o)
    assert(len(entityes) == 1)
    return entityes[0]

            
def process(input_stream):
    hdlCtx = HDLCtx()
    # s = time()
    lexer = vhdlLexer(input_stream)
    stream = CommonTokenStream(lexer)
    parser = vhdlParser(stream)
    # s2 = time()
    # print('lex, pars - build', s2 - s)
    # s = s2
    tree = parser.design_file()  # ddesign_file is first rule
    # s2 = time()
    # print('parsing          ', s2 - s)
    # s = s2
    
    walker = ParseTreeWalker();
    listener = vhdlEntityListener(hdlCtx);
    walker.walk(listener, tree);
    # s2 = time()
    # print('walking ast      ', s2 - s)
    # s = s2
    
    return hdlCtx

    
   
if __name__ == "__main__":
    # simplest_b
    # axiLite_basic_slave2
    # axi4-stream-bfm-master
    # user
    # axiLite_basic_slave
    hdlCtx = processFile('samples/iLvl/vhdl/entityExample.vhd')
    print(hdlCtx)
