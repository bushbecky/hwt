#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from subprocess import Popen, PIPE
import json, inspect, os

from vhdl_toolkit.hdlObjects.types import HdlType
from vhdl_toolkit.hdlContext import HDLCtx, BaseVhdlContext, HDLParseErr, FakeStd_logic_1164, \
    RequireImportErr

from vhdl_toolkit.hdlObjects.reference import VhdlRef
from vhdl_toolkit.hdlObjects.operators import Operator
from vhdl_toolkit.hdlObjects.operatorDefs import AllOps
from vhdl_toolkit.hdlObjects.specialValues import Unconstrained
from vhdl_toolkit.hdlObjects.portItem import PortItem 
from vhdl_toolkit.hdlObjects.variables import VHDLGeneric
from vhdl_toolkit.hdlObjects.entity import Entity
from vhdl_toolkit.hdlObjects.package import PackageHeader, PackageBody
from vhdl_toolkit.hdlObjects.architecture import Architecture
from vhdl_toolkit.hdlObjects.component import ComponentInstance 
from vhdl_toolkit.hdlObjects.value import Value

from vhdl_toolkit.synthetisator.param import Param
from vhdl_toolkit.synthetisator.rtlLevel.signal import SignalNode

from vhdl_toolkit.hdlObjects.typeDefs import INT, STR, Std_logic_vector

"""
Parser is generated by antlr4, and is in Java because in Python it is incredibly slow (20min vs 0.2s)

https://github.com/antlr/antlr4/blob/master/doc/getting-started.md
https://github.com/antlr/antlr4
https://github.com/antlr/grammars-v4/blob/master/vhdl/vhdl.g4
https://github.com/loranbriggs/Antlr/blob/master/The%20Definitive%20ANTLR%204%20Reference.pdf
"""


        
def entityFromFile(fileName):
    ctx = parseVhdl([fileName], primaryUnitsOnly=True)
    ctx = ctx['work']
    assert(len(ctx.entities.items()) == 1)
    ent = list(ctx.entities.items())[0][1]
    ent.generics.sort(key=lambda x: x.name)
    ent.port.sort(key=lambda x: x.name)
    return ent

baseDir = os.path.dirname(inspect.getfile(entityFromFile))
JAVA = 'java'
CONVERTOR = os.path.join(baseDir, "vhdlConvertor", "vhdlConvertor.jar")

class Parser():
    @staticmethod
    def exprFromJson(jExpr, ctx):
        lit = jExpr.get("literal", None)
        if lit:
            # vhldConvertor.vhdlSymbolType
            t = lit['type']
            v = lit['value']
            if t == 'ID':
                if isinstance(v[0], str):
                    ref = VhdlRef([v])
                else:
                    ref = VhdlRef.fromJson(v)
                v = ctx.lookupLocal(ref)
            elif t == 'INT':
                v = Value.fromPyVal(int(v), INT)
            elif t == 'STRING':
                v = Value.fromPyVal(str(v), STR)
            else:
                raise HDLParseErr("Unknown type of literal %s" % (t))
            return v
        binOp = jExpr['binOperator']
        if binOp:
            op0 = Parser.exprFromJson(binOp['op0'], ctx)
            operator = AllOps.opByName(binOp['operator'])
            op1 = Parser.exprFromJson(binOp['op1'], ctx)
            return SignalNode.resForOp(Operator(operator, [op0, op1]))
        raise HDLParseErr("Unparsable expression %s" % (str(jExpr)))
    
    @staticmethod    
    def portFromJson(jPort, ctx):
        v = jPort['variable']
        var_type = Parser.typeFromJson(v['type'], ctx)
        p = PortItem(v['name'], jPort['direction'], var_type)
        val = v['value']
        if val != None:
            p.defaultVal = Parser.exprFromJson(val, ctx)
        return p
    
    @staticmethod
    def typeFromJson(jType, ctx):
        try:
            t_name = VhdlRef.fromJson(jType['literal']['value'])
            t = ctx.lookupLocal(t_name)
            return t

        except KeyError:
            op = jType['binOperator']
            t_name = VhdlRef.fromJson(op['op0']['literal']['value'])
            t = ctx.lookupLocal(t_name)
            if t != FakeStd_logic_1164.std_logic_vector:
                raise NotImplementedError("Type conversion is not implemented for type %s" % t)
            width = Parser.exprFromJson(op['op1'], ctx)
            return t(width)

    @staticmethod
    def genericFromJson(jGeneric, ctx):
        t = jGeneric["type"]
        name = jGeneric['name'].lower()
        t = Parser.typeFromJson(t, ctx)
        defaultVal = Value.fromPyVal(Parser.exprFromJson(jGeneric['value'], ctx), t)

        if isinstance(t, Std_logic_vector):
            t.width.derivedWidth = int(jGeneric['value']['literal']["bits"])
        g = VHDLGeneric(name, t, defaultVal=defaultVal)
        return g
    
    @staticmethod
    def entityFromJson(jEnt, ctx, hierarchyOnly=False):
        e = Entity()
        e.name = jEnt['name']
        if not hierarchyOnly:
            for _, jGener in jEnt['generics'].items():
                g = Parser.genericFromJson(jGener, ctx)
                e.generics.append(g)
            entCtx = HDLCtx(e.name, ctx)
            e.injectCtxWithGenerics(entCtx)
            entCtx.update(ctx)
            for _ , jPort in jEnt['ports'].items():
                p = Parser.portFromJson(jPort, entCtx)
                e.port.append(p)
        return e
    
    @staticmethod
    def componentInstanceFromJson(jComp, ctx, hierarchyOnly=False):
        ci = ComponentInstance(jComp['name'], None)
        ci.entityRef = VhdlRef.fromExprJson(jComp['entityName'])
        if not hierarchyOnly:
            raise NotImplementedError()
            # [TODO] port, generics maps
        return ci
    
    @staticmethod
    def archFromJson(jArch, ctx, hierarchyOnly=False):
        a = Architecture(None)
        a.entityName = jArch["entityName"]
        a.name = jArch['name']
        for jComp in jArch['componentInstances']:
            ci = Parser.componentInstanceFromJson(jComp, ctx, hierarchyOnly=hierarchyOnly)
            a.componentInstances.append(ci)
        if not hierarchyOnly:
            raise NotImplementedError()
        return a
    
    @staticmethod
    def packageHeaderFromJson(jPh, ctx, hierarchyOnly=False):
        ph = PackageHeader(jPh['name'], ctx)
        for _, jComp in jPh[ 'components'].items():
            c = Parser.entityFromJson(jComp, ctx, hierarchyOnly=hierarchyOnly)
            ph.insertObj(c) 
        if not hierarchyOnly:
            raise NotImplementedError()
        return ph
    
    @staticmethod
    def packageBodyFromJson(jPack, ctx, hierarchyOnly=False):
        pb = PackageBody(jPack['name'], ctx)
        if not hierarchyOnly:
            raise NotImplementedError()
        return pb
        
    @staticmethod
    def parse(jsonctx, fileName, ctx, hierarchyOnly=False, primaryUnitsOnly=True):
        """
        @param fileName: vhdl filename
        @param ctx: parent HDL context
        @param hierarchyOnly: discover only presence of entities, architectures and component instances inside,
                              packages and components inside, packages 
        @param primaryUnitsOnly: parse only entities and package headers  
        """
        dependencies = set()
        try:
            for jsnU in jsonctx['usings']:
                u = VhdlRef.fromJson(jsnU)
                dependencies.add(u)
                # if ctx.lookupGlobal(u) is None:
                if not hierarchyOnly:
                    ctx.importLibFromGlobal(u)
        except RequireImportErr as e:
            e.fileName = fileName
            raise e
    
        for phName, jPh in jsonctx["packageHeaders"].items():
            ph = Parser.packageHeaderFromJson(jPh, ctx, hierarchyOnly=hierarchyOnly)
            assert(ph.name == phName)
            n = ph.name.lower() 
            if n not in ctx.packages:
                ctx.insertObj(ph)
            else:
                ctx.packages[n].update(ph)
        
        for eName, jE in jsonctx["entities"].items():
            ent = Parser.entityFromJson(jE, ctx, hierarchyOnly=hierarchyOnly)
            assert(ent.name == eName)
            ent.fileName = fileName
            ent.dependencies = dependencies
            ctx.insertObj(ent)
        
        if not primaryUnitsOnly:
            for pbName, jpBody in jsonctx["packages"].items():
                pb = Parser.packageBodyFromJson(jpBody, ctx, hierarchyOnly=hierarchyOnly)
                assert(pb.name == pbName)
                n = pb.name.lower()
                if n not in ctx.packages:
                    ph = PackageHeader(n, ctx, isDummy=True)
                    ph.insertBody(pb)
                    ctx.insertObj(ph)
                else:
                    ctx.packages[n].insertBody(pb)
        
            for jArch in jsonctx['architectures']:
                arch = Parser.archFromJson(jArch, ctx, hierarchyOnly=hierarchyOnly)
                arch.fileName = fileName
                arch.dependencies = dependencies
                ctx.insertObj(arch)

           
def parseVhdl(fileList:list, hdlCtx=None, libName="work", timeoutInterval=20, hierarchyOnly=False, primaryUnitsOnly=False):
    """
    @param fileList: list of files to parse in same context
    @param hdlCtx: parent HDL context
    @param libName: name of actual library
    @param timeoutInterval: timeout for process of external vhdl parser
    @param hierarchyOnly: discover only presence of entities, architectures and component instances inside,
                          packages and components inside, packages 
    @param primaryUnitsOnly: parse only entities and package headers  
    """
    if isinstance(fileList, str):
        fileList = [fileList]
    topCtx = hdlCtx
    if not hdlCtx:
        topCtx = BaseVhdlContext.getBaseCtx()
        BaseVhdlContext.importFakeLibs(topCtx)
        hdlCtx = HDLCtx(libName, topCtx)
        topCtx.insert(VhdlRef([libName]), hdlCtx)
    p_list = []
    for fname in fileList:
        cmd = [JAVA, "-jar", str(CONVERTOR) , fname]
        if hierarchyOnly:
            cmd.append('-h') 
            
        p = Popen(cmd, stdout=PIPE) 
        
        p.fileName = fname
        p_list.append(p)
        
    for p in p_list:
        stdoutdata, _ = p.communicate(timeout=timeoutInterval)

        if p.returncode != 0:
            raise Exception("Failed to parse file %s" % (p.fileName))
        try:
            if stdoutdata == b'':
                j = None 
            else:
                j = json.loads(stdoutdata.decode("utf-8"))
        except ValueError:
            raise Exception("Failed to parse file %s, ValueError while parsing json from convertor" % (p.fileName))
        if j:
            Parser.parse(j, p.fileName, hdlCtx, hierarchyOnly=hierarchyOnly, primaryUnitsOnly=primaryUnitsOnly)
    
    return topCtx
